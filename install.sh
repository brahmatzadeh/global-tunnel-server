#!/usr/bin/env bash
#
# Global Tunnel — One-file server setup (easy install)
# Run on the machine that will host the tunnel. Asks for domain and env, then
# installs deps, TLS, nginx, and writes .env.
#
# Usage: ./install.sh   (from repo root, or any dir — script finds repo root)
#    or: bash install.sh
# Requires: sudo (apt/nginx/certbot), Node.js 18+
#

set -e

# Find project root (directory containing package.json and server/)
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
if [[ -f "$SCRIPT_DIR/package.json" ]] && [[ -d "$SCRIPT_DIR/server" ]]; then
  PROJECT_ROOT="$SCRIPT_DIR"
else
  PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
  if [[ ! -f "$PROJECT_ROOT/package.json" ]] || [[ ! -d "$PROJECT_ROOT/server" ]]; then
    echo "Run install.sh from the global-tunnel repo root (where package.json and server/ are)."
    exit 1
  fi
fi

ENV_FILE="$PROJECT_ROOT/.env"

log() { echo "$*"; }
log_step() { echo ""; echo "=== $* ==="; }
prompt() { read -p "$* " -r; echo "$REPLY"; }
prompt_default() { read -p "$1 [$2]: " -r; echo "${REPLY:-$2}"; }
yes_no() { read -p "$1 [y/N] " -n 1 -r; echo ""; [[ $REPLY =~ ^[Yy]$ ]]; }

validate_domain() {
  local d="$1"
  [[ -n "$d" ]] && [[ "$d" =~ ^[a-zA-Z0-9]([a-zA-Z0-9.-]*[a-zA-Z0-9])?$ ]] && [[ "$d" == *.* ]]
}

# --- Collect env (domain + optional overrides) ---
log "Global Tunnel — Easy install"
log "This script will configure the server and ask for your domain and options."
log ""

log_step "1. Domain"
log "Tunnel URLs will be: https://<subdomain>.YOUR_DOMAIN"
log "Example: tunnel.example.com"
log ""

while true; do
  TUNNEL_DOMAIN=$(prompt "Tunnel domain (e.g. tunnel.example.com):")
  TUNNEL_DOMAIN=$(echo "$TUNNEL_DOMAIN" | tr -d ' ')
  if validate_domain "$TUNNEL_DOMAIN"; then
    break
  fi
  log "Invalid. Use a hostname like tunnel.example.com"
done

log_step "2. Server ports and protocol"
log "The app runs behind nginx: nginx listens on 443, the Node app on a local port."
PORT=$(prompt_default "Backend port (app listen)" "4040")
PUBLIC_PORT=$(prompt_default "Public HTTPS port (nginx)" "443")
PUBLIC_PROTOCOL=$(prompt_default "Public protocol (http or https)" "https")
log "Using: PORT=$PORT, PUBLIC_PORT=$PUBLIC_PORT, PUBLIC_PROTOCOL=$PUBLIC_PROTOCOL"
log ""

# --- Dependencies ---
log_step "3. Dependencies"
if ! command -v node >/dev/null 2>&1; then
  log "Node.js 18+ is required. Install it and run this script again."
  exit 1
fi
for cmd in certbot nginx; do
  if ! command -v $cmd >/dev/null 2>&1; then
    log "Installing $cmd..."
    sudo apt-get update -qq
    sudo apt-get install -y $cmd
  fi
done
log "Ready."
log ""

# --- DNS ---
log_step "4. DNS"
PUBLIC_IP=$(curl -s --max-time 3 169.254.169.254/latest/meta-data/public-ipv4 2>/dev/null || true)
[[ -z "$PUBLIC_IP" ]] && PUBLIC_IP="YOUR_SERVER_PUBLIC_IP"
log "Add a wildcard A record so *.$TUNNEL_DOMAIN points to this server:"
log "  Type: A   Name: *.$TUNNEL_DOMAIN (or *.tunnel etc.)   Value: $PUBLIC_IP"
log ""
if ! yes_no "DNS is ready (or you will add it later)?"; then
  log "Point DNS to this server, then run ./install.sh again."
  exit 0
fi
log ""

# --- TLS ---
log_step "5. TLS certificate (Let's Encrypt)"
CERT_PATH="/etc/letsencrypt/live/$TUNNEL_DOMAIN"
if [[ -d "$CERT_PATH" ]]; then
  log "Certificate found at $CERT_PATH"
else
  log "Get a wildcard cert. You will add a TXT record when certbot asks."
  log "Command: sudo certbot certonly --manual --preferred-challenges dns -d \"*.$TUNNEL_DOMAIN\" -d \"$TUNNEL_DOMAIN\""
  log ""
  if yes_no "Run certbot now?"; then
    sudo certbot certonly --manual --preferred-challenges dns -d "*.$TUNNEL_DOMAIN" -d "$TUNNEL_DOMAIN"
  else
    log "Run the certbot command above, then run ./install.sh again."
    exit 0
  fi
fi

if [[ ! -d "$CERT_PATH" ]]; then
  log "Certificate missing at $CERT_PATH. Run certbot first."
  exit 1
fi
log ""

# --- Nginx (embedded config) ---
log_step "6. Nginx"
NGINX_SITE="/etc/nginx/sites-available/global-tunnel"
sudo tee "$NGINX_SITE" >/dev/null << NGINXEOF
# Global Tunnel — $TUNNEL_DOMAIN (generated by install.sh)
server {
    listen 443 ssl;
    server_name $TUNNEL_DOMAIN *.$TUNNEL_DOMAIN;

    ssl_certificate     /etc/letsencrypt/live/$TUNNEL_DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/$TUNNEL_DOMAIN/privkey.pem;

    location / {
        proxy_pass http://127.0.0.1:$PORT;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Sec-WebSocket-Key \$http_sec_websocket_key;
        proxy_set_header Sec-WebSocket-Version \$http_sec_websocket_version;
    }
}
NGINXEOF

sudo ln -sf "$NGINX_SITE" /etc/nginx/sites-enabled/
if ! sudo nginx -t 2>/dev/null; then
  log "Nginx config test failed. Check $NGINX_SITE"
  exit 1
fi
sudo systemctl reload nginx
log "Nginx configured and reloaded."
log ""

# --- .env ---
log_step "7. Environment (.env)"
cat > "$ENV_FILE" << ENVEOF
# Global Tunnel — written by install.sh
TUNNEL_DOMAIN=$TUNNEL_DOMAIN
PORT=$PORT
PUBLIC_PORT=$PUBLIC_PORT
PUBLIC_PROTOCOL=$PUBLIC_PROTOCOL
ENVEOF
log "Wrote $ENV_FILE"
log ""

# --- npm ---
log_step "8. npm install"
if [[ -f "$PROJECT_ROOT/package.json" ]]; then
  (cd "$PROJECT_ROOT" && npm install --silent)
  log "Done."
else
  log "No package.json in $PROJECT_ROOT"
fi
log ""

# --- Systemd service (run on boot, restart on failure) ---
log_step "9. Systemd service"
RUN_AS_USER="${SUDO_USER:-$USER}"
NODE_BIN="$(command -v node)"
if [[ -z "$NODE_BIN" ]]; then
  log "Could not find node in PATH. Skipping service install."
else
  SVC_DEST="/etc/systemd/system/global-tunnel.service"
  sed "s|REPLACE_PROJECT_ROOT|$PROJECT_ROOT|g;s|REPLACE_USER|$RUN_AS_USER|g;s|REPLACE_NODE_BIN|$NODE_BIN|g" \
    "$PROJECT_ROOT/global-tunnel.service" | sudo tee "$SVC_DEST" >/dev/null
  sudo systemctl daemon-reload
  sudo systemctl enable global-tunnel
  sudo systemctl start global-tunnel
  log "Service installed and started. It will start automatically on boot."
fi
log ""

# --- Done ---
log_step "Setup complete"
log "The tunnel server is running as a systemd service (starts on boot, restarts on failure)."
log "Manage it with:"
log "  sudo systemctl status global-tunnel   # check status"
log "  sudo systemctl restart global-tunnel  # restart"
log "  sudo systemctl stop global-tunnel     # stop"
log ""
WS_PROTOCOL="wss"
[[ "$PUBLIC_PROTOCOL" != "https" ]] && WS_PROTOCOL="ws"
log "From any machine, run the client:"
log "  npx global-tunnel --port 3000 --server $WS_PROTOCOL://$TUNNEL_DOMAIN"
log "  npx global-tunnel --port 3000 --server $WS_PROTOCOL://$TUNNEL_DOMAIN --subdomain myapp"
log ""
